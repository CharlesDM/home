# Curriculum

Hello! And welcome to the HackYourFuture Belgium Curriculum.

## Programming is Communication

Software creates a complicated series of communications between developers, computers, users and society in general. This diagram gives a simplified overview of the different channels of communication you'll explore while at HYF Belgium:

![rhetorical situation](../.gitbook/assets/rhetorical-situation.png)

## Layers of Skills

Software Development is a many layered skill. One way to break it down is to think of these layers:

1. **Source Code**: _The basic literacy of programming_
   * Learning the key words \(_vocabulary_\) and syntax \(_grammar_\) for your programming language
   * Being able to read your code out loud, tracing it's execution as a computer would
   * Understanding what the developer wanted to say with their code
   * > **Welcome to JS** will focus on these skills\_
2. **Machine Instructions**: _The basic mechanics of programming_
   * Understanding the life-cycle of your program
   * Understand how the computer will interpret your source code to create a running program
   * Understand what about your code matters to the computer, and what matters to people
   * Fixing syntax errors that occur when you try to run your code
   * Predicting which lines of code will be executed in which order
   * Predicting how each line of code will change what is stored in program memory
   * Reading error messages & callstacks to fix fix semantic errors that occur when you run your code
   * > **Debugging** will focus on these skills\_
3. **Problem Solving & Algorithms**: _Breaking down large problems to be solved in small steps_
   * Understanding a coding challenge and being able to break it down in different ways
   * Determining which solution strategies are correct for which types of problems
   * Understanding how test cases are used to describe your solution strategy
   * Identifying the best language feature to use with your strategy
   * Reading test cases to understand how code is _supposed to_ behave
   * Using Test Cases to structure your solution design process \(Test Driven Development\)
   * Identifying and isolating mistakes in your code by reading failing test cases
   * Demonstrating your code does what you think it does by passing test cases
   * > _**Behavior, Strategy, Implementation** Module will focus on these skills_
4. **Software Design**: _Organizing smaller pieces of code into full software solutions_
   * > _Every module starting with **Separation of Concerns** will focus on these skills_
5. **Planning and Collaborating**: _Breaking down large problems into tasks that can be shared_
   * > _This is introduced in the **Agile Develompent** module and practiced in every other module_
6. **Context**: _Who uses a program, what is it's impact, and where did it come from?_
   * Real people will use your software, is it accessible to them?
   * Your software exists in a society, what it's impact on others?
   * Someone planned and build your software, what were their motivations?

## Learning Objectives

This curriculum is broken up into modules of 2-5 weeks. Each of the modules introduces a new principle of software development, building on the last module to give you a 360 view what it takes to become a developer your colleagues can rely on.

Each module has it's own learning objectives determined by the sub-skills required to complete the module's projects. You can prioritize your study time and assess yourself based on each objective's priority:

* ü•ö: You can apply this skill comfortably within the module's learning task with access to references. A learning task submitted at the end of the module should demonstrate proficiency in these objectives.
* üê£: You can apply this skill with effort and frequent support from references. A learning task submitted at the end of the module should demonstrate partial application of these skills.
* üê•: You understands the basic zoomed-out idea of this skill but may not be comfortable or proficient applying it. A learning task submitted at the end of the module may include attempts at applying these skills.
* üêî: learning this skill is not required for the module's learning task but is relevant, if you are ü•ö, üê£ and üê• objectives. A learning task submitted at the end of the module should not demonstrate these skills if the higher priorities are not accounted for.

## Modules Overview

* [Application](application/) and [Precourse](precourse/):
  * First steps into HTML, CSS & JS.
  * What is the internet andd web development.
  * Set up your computer for the rest of the course.
* [Workflows](workflows/), [Agile Development](agile-development/) and [UX/UI Design](ux-ui-design/)
  * Master your computer and development workflows
  * Design, plan and develop accessible web pages
  * Learn about collaboration and Open Source software
* [Welcome to JS](welcome-to-js/), [Debugging](debugging.md) and [Behavior, Strategy, Implementation](behavior-strategy-implementation/)
  * Reading, describing, modifying and writing small JS programs.
  * Understanding how the JavaScript engine reads and executes your instructions.
  * Documenting and testing JS functions.
  * Collaborating on a JS code base: code review and consistent code quality.
* [Separation of Concerns](separation-of-concerns/) and [Architecture](architecture.md)
  * Event-Driven programming in the browser.
  * Function Roles: organizing code based on the role it plays in your program.
  * Planning and collaborating on interactive JS web pages.
  * Layers and abstraction.
  * Program state and persistence.
* [Asynchronous Programming](asynchronous-programming.md), [Web Apps](web-apps.md) and [Databases](databases.md)
  * The JavaScript Event Loop.
  * Different JS runtime environments: Browser and Node.js
  * Different ways to manage data: remote APIs, the file system and relational databases.
  * First introduction to the client/server model and HTTP.
  * Fullstack applications: connecting the frontend to the backend.
* [Final Project](final-project/)
  * Developing a digital product from ideation to delivery.
  * Practicing the agile/scrum methodology.
  * Continuous deployment, cloud hosting and site reliability
  * Branding and pitching.

